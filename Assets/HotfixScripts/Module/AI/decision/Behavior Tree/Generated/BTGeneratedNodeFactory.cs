using System;
using System.Collections.Generic;
using System.Globalization;
using BT.RuntimeSerialization;

namespace BT
{
    // Auto-generated by BTCodegen.cs. Do not edit by hand.
    public static class BTGeneratedNodeFactory
    {
        public enum NodeKind { Leaf = 0, Decorator = 1, Composite = 2 }

        public static NodeKind GetKind(string typeId)
        {
            switch (typeId)
            {
                case "BT.BTParallel":
                case "BT.BTRandom":
                case "BT.BTSelector":
                case "BT.BTSequence":
                    return NodeKind.Composite;
                case "BT.BTInverted":
                case "BT.BTProbability":
                case "BT.BTTimer":
                case "BT.BTinterval":
                    return NodeKind.Decorator;
                default: return NodeKind.Leaf;
            }
        }

        public static BTNode CreateComposite(string typeId, List<BTArgJson> args)
        {
            switch (typeId)
            {
                case "BT.BTParallel": return new BT.BTParallel((BT.ParallelType)GetInt(args, "type", 0));
                case "BT.BTRandom": return new BT.BTRandom();
                case "BT.BTSelector": return new BT.BTSelector();
                case "BT.BTSequence": return new BT.BTSequence();
                default: return null;
            }
        }

        public static BTNode CreateDecorator(string typeId, List<BTArgJson> args, BTNode child)
        {
            switch (typeId)
            {
                case "BT.BTInverted": return new BT.BTInverted(child);
                case "BT.BTProbability": return new BT.BTProbability(GetInt(args, "Probability", 0), child);
                case "BT.BTTimer": return new BT.BTTimer(GetFloat(args, "timer", 0f), child);
                case "BT.BTinterval": return new BT.BTinterval(GetString(args, "databaseName", ""), GetFloat(args, "time", 0f), child);
                default: return null;
            }
        }

        public static BTNode CreateLeaf(string typeId, List<BTArgJson> args)
        {
            switch (typeId)
            {
                case "DebugAction":
                {
                    var node = new DebugAction();
                    node.logInfo = GetString(args, "logInfo", "");
                    node.type = (DebugAction.DebugActionType)GetInt(args, "type", 0);
                    return node;
                }
                default: return null;
            }
        }

        static string GetString(List<BTArgJson> args, string name, string defaultValue)
        {
            if (args == null) return defaultValue;
            for (var i = 0; i < args.Count; i++)
            {
                var a = args[i];
                if (a != null && a.name == name) return a.value ?? defaultValue;
            }
            return defaultValue;
        }

        static int GetInt(List<BTArgJson> args, string name, int defaultValue)
        {
            var s = GetString(args, name, null);
            if (string.IsNullOrEmpty(s)) return defaultValue;
            return int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture, out var v) ? v : defaultValue;
        }

        static float GetFloat(List<BTArgJson> args, string name, float defaultValue)
        {
            var s = GetString(args, name, null);
            if (string.IsNullOrEmpty(s)) return defaultValue;
            return float.TryParse(s, NumberStyles.Float, CultureInfo.InvariantCulture, out var v) ? v : defaultValue;
        }

        static bool GetBool(List<BTArgJson> args, string name, bool defaultValue)
        {
            var s = GetString(args, name, null);
            if (string.IsNullOrEmpty(s)) return defaultValue;
            if (bool.TryParse(s, out var v)) return v;
            return int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture, out var i) ? i != 0 : defaultValue;
        }
    }
}
