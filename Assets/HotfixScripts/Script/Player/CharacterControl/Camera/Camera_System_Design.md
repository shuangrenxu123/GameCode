# RPGæ¸¸æˆæ‘„åƒæœºæ§åˆ¶ç³»ç»Ÿè®¾è®¡

## æ¦‚è¿°

æœ¬æ–‡æ¡£æ€»ç»“äº†RPGæ¸¸æˆä¸­å¸¸è§çš„æ‘„åƒæœºæ§åˆ¶æ•ˆæœï¼Œåˆ†æäº†ç°æœ‰çš„æ‘„åƒæœºç³»ç»Ÿå®ç°ï¼Œå¹¶æå‡ºäº†ä¸€ä¸ªæ¨¡å—åŒ–ã€å¯æ‰©å±•çš„æ‘„åƒæœºç³»ç»Ÿæ¶æ„è®¾è®¡ã€‚

## 1. å¸¸è§çš„RPGæ‘„åƒæœºæ§åˆ¶æ•ˆæœ

### 1.1 åŸºç¡€è·Ÿéšæ•ˆæœ

#### å¹³æ»‘è·Ÿéš (Smooth Follow)
- **æè¿°**: æ‘„åƒæœºä»¥å¹³æ»‘æ’å€¼çš„æ–¹å¼è·Ÿéšç›®æ ‡è§’è‰²ç§»åŠ¨
- **å‚æ•°**: è·Ÿéšé€Ÿåº¦ã€è·Ÿéšè·ç¦»ã€è·Ÿéšé«˜åº¦
- **åº”ç”¨åœºæ™¯**: è§’è‰²ç§»åŠ¨ã€åœºæ™¯æ¼«æ¸¸
- **å®ç°è¦ç‚¹**: ä½¿ç”¨Lerpæˆ–SmoothDampè¿›è¡Œä½ç½®æ’å€¼

#### æ™ºèƒ½è·Ÿéš (Smart Follow)
- **æè¿°**: æ ¹æ®åœ°å½¢å’Œç¯å¢ƒæ™ºèƒ½è°ƒæ•´æ‘„åƒæœºä½ç½®
- **å‚æ•°**: åœ°å½¢æ£€æµ‹åŠå¾„ã€é¿éšœè·ç¦»
- **åº”ç”¨åœºæ™¯**: å¤æ‚åœ°å½¢ç¯å¢ƒ
- **å®ç°è¦ç‚¹**: å°„çº¿æ£€æµ‹ã€ç¢°æ’é¿å…ç®—æ³•

### 1.2 å±å¹•éœ‡åŠ¨æ•ˆæœ

#### å†²å‡»éœ‡åŠ¨ (Impact Shake)
- **æè¿°**: å—åˆ°æ”»å‡»æˆ–é‡Šæ”¾æŠ€èƒ½æ—¶äº§ç”ŸçŸ­æš‚éœ‡åŠ¨
- **å‚æ•°**: éœ‡åŠ¨å¹…åº¦ã€éœ‡åŠ¨é¢‘ç‡ã€æŒç»­æ—¶é—´
- **åº”ç”¨åœºæ™¯**: æˆ˜æ–—ç³»ç»Ÿã€æŠ€èƒ½é‡Šæ”¾
- **å®ç°è¦ç‚¹**: éšæœºåç§»ã€è¡°å‡ç®—æ³•

#### ç¯å¢ƒéœ‡åŠ¨ (Environmental Shake)
- **æè¿°**: ç¯å¢ƒäº‹ä»¶å¼•èµ·çš„æŒç»­éœ‡åŠ¨
- **å‚æ•°**: éœ‡åŠ¨å¼ºåº¦ã€éœ‡åŠ¨æ¨¡å¼ã€è§¦å‘æ¡ä»¶
- **åº”ç”¨åœºæ™¯**: åœ°éœ‡ã€çˆ†ç‚¸ç­‰ç¯å¢ƒæ•ˆæœ
- **å®ç°è¦ç‚¹**: åŸºäºäº‹ä»¶çš„è§¦å‘æœºåˆ¶

#### è‡ªå®šä¹‰éœ‡åŠ¨æ¨¡å¼
- **æè¿°**: æ”¯æŒå¤šç§é¢„è®¾çš„éœ‡åŠ¨æ¨¡å¼
- **å‚æ•°**: éœ‡åŠ¨æ›²çº¿ã€è¡°å‡å‡½æ•°
- **åº”ç”¨åœºæ™¯**: ä¸åŒçš„æŠ€èƒ½å’Œç¯å¢ƒæ•ˆæœ
- **å®ç°è¦ç‚¹**: æ›²çº¿ç¼–è¾‘å™¨ã€æ¨¡å¼é…ç½®ç³»ç»Ÿ

### 1.3 é”å®šç³»ç»Ÿ

#### è‡ªåŠ¨é”å®š (Auto Lock-On)
- **æè¿°**: è‡ªåŠ¨é€‰æ‹©æœ€è¿‘æˆ–æœ€åˆé€‚çš„æ•Œäººè¿›è¡Œé”å®š
- **å‚æ•°**: é”å®šè·ç¦»ã€é”å®šè§’åº¦ã€ä¼˜å…ˆçº§æƒé‡
- **åº”ç”¨åœºæ™¯**: æˆ˜æ–—ç³»ç»Ÿ
- **å®ç°è¦ç‚¹**: çƒå½¢æ£€æµ‹ã€è§’åº¦è®¡ç®—ã€ä¼˜å…ˆçº§æ’åº

#### æ‰‹åŠ¨é”å®š (Manual Lock-On)
- **æè¿°**: ç©å®¶æ‰‹åŠ¨é€‰æ‹©é”å®šç›®æ ‡
- **å‚æ•°**: é”å®šåˆ‡æ¢é€Ÿåº¦ã€ç›®æ ‡æŒ‡ç¤ºå™¨
- **åº”ç”¨åœºæ™¯**: Bossæˆ˜ã€å¤šç›®æ ‡æˆ˜æ–—
- **å®ç°è¦ç‚¹**: è¾“å…¥æ£€æµ‹ã€UIæŒ‡ç¤ºå™¨

### 1.4 è§†è§’åˆ‡æ¢æ•ˆæœ

#### ç¬¬ä¸€/ç¬¬ä¸‰äººç§°åˆ‡æ¢
- **æè¿°**: åœ¨ç¬¬ä¸€äººç§°å’Œç¬¬ä¸‰äººç§°è§†è§’é—´åˆ‡æ¢
- **å‚æ•°**: åˆ‡æ¢åŠ¨ç”»æ—¶é—´ã€è§†è§’å‚æ•°
- **åº”ç”¨åœºæ™¯**: ä¸åŒæ¸¸æˆæ¨¡å¼
- **å®ç°è¦ç‚¹**: ç›¸æœºå‚æ•°åˆ‡æ¢ã€åŠ¨ç”»è¿‡æ¸¡

#### è¿‡è‚©è§†è§’ (Over-the-Shoulder)
- **æè¿°**: ç»å…¸çš„ç¬¬ä¸‰äººç§°å°„å‡»æ¸¸æˆè§†è§’
- **å‚æ•°**: è‚©éƒ¨åç§»ã€è§†è§’è§’åº¦ã€è·ç¦»
- **åº”ç”¨åœºæ™¯**: åŠ¨ä½œRPGæˆ˜æ–—
- **å®ç°è¦ç‚¹**: éª¨éª¼ç»‘å®šã€åŠ¨æ€è°ƒæ•´

#### ä¿¯è§†è§†è§’ (Top-Down)
- **æè¿°**: ä¿¯è§†è§†è§’ï¼Œé€‚åˆç­–ç•¥ç±»æ¸¸æˆ
- **å‚æ•°**: ä¿¯è§†è§’åº¦ã€ç¼©æ”¾èŒƒå›´
- **åº”ç”¨åœºæ™¯**: å›åˆåˆ¶RPGã€ç­–ç•¥æ¸¸æˆ
- **å®ç°è¦ç‚¹**: æ­£äº¤æŠ•å½±ã€ç¼©æ”¾æ§åˆ¶

### 1.5 æˆ˜æ–—ç‰¹æ®Šæ•ˆæœ

#### é•œå¤´æ‹‰è¿‘ (Zoom In)
- **æè¿°**: æˆ˜æ–—å¼€å§‹æˆ–é‡è¦æ—¶åˆ»æ‹‰è¿‘é•œå¤´
- **å‚æ•°**: æ‹‰è¿‘é€Ÿåº¦ã€ç›®æ ‡è·ç¦»ã€æŒç»­æ—¶é—´
- **åº”ç”¨åœºæ™¯**: æŠ€èƒ½é‡Šæ”¾ã€å‰§æƒ…é«˜æ½®
- **å®ç°è¦ç‚¹**: ç¼“åŠ¨å‡½æ•°ã€äº‹ä»¶è§¦å‘

#### é•œå¤´æ‹‰è¿œ (Zoom Out)
- **æè¿°**: å±•ç¤ºæ›´å¤§èŒƒå›´åœºæ™¯æˆ–é€ƒè„±é•œå¤´
- **å‚æ•°**: æ‹‰è¿œé€Ÿåº¦ã€æœ€å¤§è·ç¦»ã€æ¢å¤æ—¶é—´
- **åº”ç”¨åœºæ™¯**: èŒƒå›´æŠ€èƒ½ã€åœºæ™¯å±•ç¤º
- **å®ç°è¦ç‚¹**: è·ç¦»æ’å€¼ã€è‡ªåŠ¨æ¢å¤

#### æ…¢é•œå¤´æ•ˆæœ (Slow Motion)
- **æè¿°**: æ—¶é—´å‡ç¼“é…åˆé•œå¤´ç‰¹å†™
- **å‚æ•°**: æ—¶é—´ç¼©æ”¾æ¯”ä¾‹ã€æŒç»­æ—¶é—´
- **åº”ç”¨åœºæ™¯**: é‡è¦æˆ˜æ–—ã€æŠ€èƒ½é‡Šæ”¾
- **å®ç°è¦ç‚¹**: Time.timeScaleæ§åˆ¶

### 1.6 åœºæ™¯è¿‡æ¸¡æ•ˆæœ

#### åœºæ™¯åˆ‡æ¢ (Scene Transition)
- **æè¿°**: åœ¨ä¸åŒåœºæ™¯é—´å¹³æ»‘è¿‡æ¸¡
- **å‚æ•°**: è¿‡æ¸¡æ—¶é—´ã€è¿‡æ¸¡æ›²çº¿
- **åº”ç”¨åœºæ™¯**: åŒºåŸŸåˆ‡æ¢ã€å®¤å†…å¤–è½¬æ¢
- **å®ç°è¦ç‚¹**: è·¯å¾„è§„åˆ’ã€å¹³æ»‘æ’å€¼

#### å›ºå®šç‚¹ä½ (Fixed Positions)
- **æè¿°**: é¢„è®¾çš„å›ºå®šæ‘„åƒæœºä½ç½®
- **å‚æ•°**: ä½ç½®åˆ—è¡¨ã€åˆ‡æ¢æ¡ä»¶
- **åº”ç”¨åœºæ™¯**: å‰§æƒ…åœºæ™¯ã€é‡è¦åœ°ç‚¹
- **å®ç°è¦ç‚¹**: ä½ç½®ç®¡ç†ã€æ¡ä»¶åˆ¤æ–­

### 1.7 é«˜çº§æ•ˆæœ

#### è·¯å¾„è·Ÿéš (Path Following)
- **æè¿°**: æ‘„åƒæœºæ²¿é¢„è®¾è·¯å¾„ç§»åŠ¨
- **å‚æ•°**: è·¯å¾„ç‚¹ã€ç§»åŠ¨é€Ÿåº¦ã€æ’å€¼æ–¹å¼
- **åº”ç”¨åœºæ™¯**: è¿‡åœºåŠ¨ç”»ã€è½¨é“é•œå¤´
- **å®ç°è¦ç‚¹**: è´å¡å°”æ›²çº¿ã€è·¯å¾„ç¼–è¾‘å™¨

#### åŠ¨æ€æ„å›¾ (Dynamic Composition)
- **æè¿°**: æ ¹æ®åœºæ™¯å…ƒç´ åŠ¨æ€è°ƒæ•´æ„å›¾
- **å‚æ•°**: æ„å›¾è§„åˆ™ã€æƒé‡è®¡ç®—
- **åº”ç”¨åœºæ™¯**: å‰§æƒ…è¡¨ç°ã€ç¯å¢ƒå™äº‹
- **å®ç°è¦ç‚¹**: è§†è§‰æƒé‡è®¡ç®—ã€æ„å›¾ç®—æ³•

## 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```mermaid
graph TB
    CameraManager[æ‘„åƒæœºç®¡ç†å™¨]
    CameraController[æ‘„åƒæœºæ§åˆ¶å™¨]
    CameraEffects[æ•ˆæœç³»ç»Ÿ]
    CameraConfig[é…ç½®ç³»ç»Ÿ]
    CameraState[çŠ¶æ€ç®¡ç†]
    InputHandler[è¾“å…¥å¤„ç†]
    EventSystem[äº‹ä»¶ç³»ç»Ÿ]

    CameraManager --> CameraController
    CameraManager --> CameraEffects
    CameraManager --> CameraConfig
    CameraManager --> CameraState
    CameraManager --> InputHandler
    CameraManager --> EventSystem

    CameraEffects --> ShakeEffect[éœ‡åŠ¨æ•ˆæœ]
    CameraEffects --> LockEffect[é”å®šæ•ˆæœ]
    CameraEffects --> ZoomEffect[ç¼©æ”¾æ•ˆæœ]
    CameraEffects --> TransitionEffect[è¿‡æ¸¡æ•ˆæœ]
    CameraEffects --> FollowEffect[è·Ÿéšæ•ˆæœ]
    CameraEffects --> RotationEffect[æ—‹è½¬æ•ˆæœ]

    CameraConfig --> EffectConfigs[æ•ˆæœé…ç½®]
    CameraConfig --> CameraProfiles[æ‘„åƒæœºé…ç½®]
    CameraConfig --> ProfileManager[é…ç½®ç®¡ç†å™¨]

    CameraState --> CurrentState[å½“å‰çŠ¶æ€]
    CameraState --> StateHistory[çŠ¶æ€å†å²]
    CameraState --> StateTransitions[çŠ¶æ€è¿‡æ¸¡]

    InputHandler --> CameraInput[æ‘„åƒæœºè¾“å…¥]
    InputHandler --> EffectTriggers[æ•ˆæœè§¦å‘å™¨]

    EventSystem --> CameraEvents[æ‘„åƒæœºäº‹ä»¶]
    EventSystem --> EffectEvents[æ•ˆæœäº‹ä»¶]
```

### 2.2 æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### æ‘„åƒæœºç®¡ç†å™¨ (CameraManager)
```csharp
public class CameraManager : Singleton<CameraManager>
{
    private CameraController mainCamera;
    private CameraEffectSystem effectSystem;
    private CameraConfigManager configManager;
    private CameraStateManager stateManager;

    public void Initialize(Camera mainCamera, Transform target);
    public void UpdateCamera(float deltaTime);
    public void ApplyEffect(string effectName, EffectParams parameters);
    public void SwitchProfile(string profileName);
}
```

#### æ•ˆæœç³»ç»Ÿ (CameraEffectSystem)
```csharp
public abstract class CameraEffect
{
    public string EffectName { get; protected set; }
    public bool IsActive { get; protected set; }
    public float Priority { get; set; }

    public abstract void Activate(EffectParams parameters);
    public abstract void Deactivate();
    public abstract void Update(float deltaTime);
    public abstract Vector3 ModifyPosition(Vector3 basePosition);
    public abstract Quaternion ModifyRotation(Quaternion baseRotation);
}
```

#### é…ç½®ç³»ç»Ÿ (CameraConfigManager)
```csharp
[Serializable]
public class CameraProfile
{
    public string profileName;
    public Vector3 defaultOffset;
    public float defaultDistance;
    public float minDistance;
    public float maxDistance;
    public float rotationSpeed;
    public float zoomSpeed;
    public List<EffectConfig> effectConfigs;
}

[Serializable]
public class EffectConfig
{
    public string effectType;
    public Dictionary<string, float> parameters;
    public AnimationCurve intensityCurve;
}
```

#### çŠ¶æ€ç®¡ç† (CameraStateManager)
```csharp
public class CameraState
{
    public Vector3 position;
    public Quaternion rotation;
    public float distance;
    public float fieldOfView;
    public List<ActiveEffect> activeEffects;
    public Dictionary<string, object> customData;
}

public class CameraStateManager
{
    private Stack<CameraState> stateHistory;
    private CameraState currentState;

    public void SaveCurrentState();
    public void RestorePreviousState();
    public void ApplyStateTransition(CameraState targetState, float duration);
}
```

### 2.3 æ•ˆæœç»„åˆç­–ç•¥

#### ä¼˜å…ˆçº§ç³»ç»Ÿ
- æ¯ä¸ªæ•ˆæœéƒ½æœ‰ä¼˜å…ˆçº§æ•°å€¼
- é«˜ä¼˜å…ˆçº§æ•ˆæœå¯ä»¥è¦†ç›–ä½ä¼˜å…ˆçº§æ•ˆæœ
- ç›¸åŒä¼˜å…ˆçº§æŒ‰æ¿€æ´»é¡ºåºå¤„ç†

#### æ•ˆæœæ ˆ (Effect Stack)
- æ•ˆæœæŒ‰ä¼˜å…ˆçº§æ’åº
- æ¯ä¸ªæ•ˆæœç‹¬ç«‹ä¿®æ”¹ç›¸æœºå‚æ•°
- æ”¯æŒæ•ˆæœçš„åŠ¨æ€æ·»åŠ å’Œç§»é™¤

#### å‚æ•°èåˆ (Parameter Blending)
- å¤šä¸ªæ•ˆæœå¯èƒ½å½±å“åŒä¸€å‚æ•°
- ä½¿ç”¨åŠ æƒå¹³å‡æˆ–æœ€å¤§å€¼ç­–ç•¥
- æ”¯æŒè‡ªå®šä¹‰èåˆå‡½æ•°

### 2.5 æ•ˆæœäº¤äº’æµç¨‹

```mermaid
sequenceDiagram
    participant M as CameraManager
    participant E as EffectSystem
    participant S as StateManager
    participant C as CameraController

    M->>E: UpdateEffects(deltaTime)
    E->>E: ProcessActiveEffects()
    E->>E: CalculateCombinedEffects()
    E->>S: ApplyEffectModifications()
    S->>S: UpdateCameraState()
    S->>C: ApplyFinalTransform()
    C->>C: SetCameraPositionAndRotation()
```

### 2.6 è¯¦ç»†æ¥å£è®¾è®¡

#### æ ¸å¿ƒæ¥å£
```csharp
public interface ICameraEffect
{
    string EffectName { get; }
    float Priority { get; set; }
    bool IsActive { get; }

    void Activate(CameraEffectContext context);
    void Deactivate();
    void Update(float deltaTime);
    CameraEffectResult ModifyCamera(CameraEffectInput input);
}

public struct CameraEffectContext
{
    public Camera targetCamera;
    public Transform targetTransform;
    public Vector3 basePosition;
    public Quaternion baseRotation;
    public float deltaTime;
    public Dictionary<string, object> parameters;
}

public struct CameraEffectResult
{
    public Vector3 modifiedPosition;
    public Quaternion modifiedRotation;
    public float modifiedFieldOfView;
    public bool overridePosition;
    public bool overrideRotation;
    public bool overrideFOV;
}
```

### 2.4 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### å¯¹è±¡æ± åŒ– (Object Pooling)
- é¢‘ç¹åˆ›å»ºé”€æ¯çš„å¯¹è±¡ä½¿ç”¨å¯¹è±¡æ± 
- å‡å°‘GCå‹åŠ›ï¼Œæé«˜æ€§èƒ½

#### è§†é”¥å‰”é™¤ (Frustum Culling)
- åªæ›´æ–°åœ¨è§†é‡å†…çš„å¯¹è±¡
- å‡å°‘è®¡ç®—é‡

#### LODç³»ç»Ÿ (Level of Detail)
- æ ¹æ®è·ç¦»è°ƒæ•´æ•ˆæœå¤æ‚åº¦
- è¿œè·ç¦»ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬

## 3. ç°æœ‰ä»£ç åˆ†æ

### 3.1 å½“å‰å®ç°ç‰¹ç‚¹

ç°æœ‰Camera3D.cså®ç°å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

#### ä¼˜ç‚¹
- åŒ…å«åŸºç¡€çš„è·Ÿéšã€æ—‹è½¬ã€ç¼©æ”¾åŠŸèƒ½
- å®ç°äº†æ•Œäººé”å®šç³»ç»Ÿ
- æœ‰ç¢°æ’æ£€æµ‹æœºåˆ¶
- æä¾›äº†ä¸°å¯Œçš„é…ç½®å‚æ•°

#### ç¼ºç‚¹
- å•ä½“æ¶æ„ï¼ŒåŠŸèƒ½è€¦åˆåº¦é«˜
- å±å¹•éœ‡åŠ¨åŠŸèƒ½ä¸å®Œæ•´
- ç¼ºä¹æ¨¡å—åŒ–è®¾è®¡
- çŠ¶æ€ç®¡ç†ä¸å¤Ÿæ¸…æ™°
- æ‰©å±•æ€§æœ‰é™

### 3.2 é‡æ„å»ºè®®

#### åŠŸèƒ½æ‹†åˆ†
```csharp
// å»ºè®®æ‹†åˆ†ä¸ºå¤šä¸ªç»„ä»¶
public class CameraFollower : MonoBehaviour // åŸºç¡€è·Ÿéš
public class CameraRotator : MonoBehaviour  // æ—‹è½¬æ§åˆ¶
public class CameraZoomer : MonoBehaviour   // ç¼©æ”¾æ§åˆ¶
public class CameraCollision : MonoBehaviour // ç¢°æ’æ£€æµ‹
public class CameraLockOn : MonoBehaviour  // é”å®šç³»ç»Ÿ
public class CameraShake : MonoBehaviour   // éœ‡åŠ¨æ•ˆæœ
```

#### é…ç½®å¤–éƒ¨åŒ–
```csharp
// å°†é…ç½®ç§»åˆ°å¤–éƒ¨é…ç½®æ–‡ä»¶
public class CameraProfileConfig
{
    public FollowSettings followSettings;
    public RotationSettings rotationSettings;
    public ZoomSettings zoomSettings;
    public CollisionSettings collisionSettings;
    public LockOnSettings lockOnSettings;
    public ShakeSettings shakeSettings;
}
```

## 4. å®ç°å»ºè®®å’Œæœ€ä½³å®è·µ

### 4.1 å¼€å‘é˜¶æ®µå»ºè®®

#### é˜¶æ®µä¸€ï¼šåŸºç¡€ç³»ç»Ÿ
1. å®ç°æ ¸å¿ƒçš„CameraManager
2. å»ºç«‹åŸºç¡€çš„è·Ÿéšç³»ç»Ÿ
3. æ·»åŠ é…ç½®ç®¡ç†åŠŸèƒ½

#### é˜¶æ®µäºŒï¼šæ•ˆæœç³»ç»Ÿ
1. å®ç°å„ç§æ‘„åƒæœºæ•ˆæœ
2. å»ºç«‹æ•ˆæœä¼˜å…ˆçº§ç³»ç»Ÿ
3. æ·»åŠ æ•ˆæœç»„åˆé€»è¾‘

#### é˜¶æ®µä¸‰ï¼šé«˜çº§åŠŸèƒ½
1. å®ç°çŠ¶æ€ç®¡ç†
2. æ·»åŠ è¿‡æ¸¡åŠ¨ç”»
3. ä¼˜åŒ–æ€§èƒ½

### 4.2 æœ€ä½³å®è·µ

#### ä»£ç ç»„ç»‡
- å•ä¸€èŒè´£åŸåˆ™ï¼šæ¯ä¸ªç±»åªè´Ÿè´£ä¸€ç§åŠŸèƒ½
- ä¾èµ–æ³¨å…¥ï¼šå‡å°‘ç±»é—´è€¦åˆ
- äº‹ä»¶é©±åŠ¨ï¼šä½¿ç”¨äº‹ä»¶ç³»ç»Ÿé€šä¿¡

#### æ€§èƒ½ä¼˜åŒ–
- ä½¿ç”¨å¯¹è±¡æ± ç®¡ç†ä¸´æ—¶å¯¹è±¡
- é¿å…æ¯å¸§æ‰§è¡Œæ˜‚è´µçš„è®¡ç®—
- ä½¿ç”¨å¤šçº¿ç¨‹å¤„ç†å¤æ‚è®¡ç®—

#### å¯ç»´æŠ¤æ€§
- è¯¦ç»†çš„æ³¨é‡Šå’Œæ–‡æ¡£
- ç»Ÿä¸€çš„å‘½åè§„èŒƒ
- é…ç½®å¤–éƒ¨åŒ–

### 4.3 è°ƒè¯•å’Œæµ‹è¯•

#### è°ƒè¯•åŠŸèƒ½
- å¯è§†åŒ–è°ƒè¯•ä¿¡æ¯æ˜¾ç¤º
- æ•ˆæœä¼˜å…ˆçº§æ˜¾ç¤º
- æ€§èƒ½æŒ‡æ ‡ç›‘æ§

#### æµ‹è¯•å»ºè®®
- å•å…ƒæµ‹è¯•å„ä¸ªæ•ˆæœç»„ä»¶
- é›†æˆæµ‹è¯•æ•ˆæœç»„åˆ
- æ€§èƒ½æµ‹è¯•å‹åŠ›åœºæ™¯

### 4.4 å…·ä½“å®ç°ç¤ºä¾‹

#### æ ¸å¿ƒæ¥å£å®ç°
```csharp
public interface ICameraEffect
{
    string EffectName { get; }
    float Priority { get; set; }
    bool IsActive { get; }

    void Activate(CameraEffectContext context);
    void Deactivate();
    void Update(float deltaTime);
    CameraEffectResult ModifyCamera(CameraEffectInput input);
}

public struct CameraEffectContext
{
    public UnityEngine.Camera targetCamera;
    public Transform targetTransform;
    public Vector3 basePosition;
    public Quaternion baseRotation;
    public float deltaTime;
    public Dictionary<string, object> parameters;
}

public struct CameraEffectResult
{
    public Vector3 modifiedPosition;
    public Quaternion modifiedRotation;
    public float modifiedFieldOfView;
    public bool overridePosition;
    public bool overrideRotation;
    public bool overrideFOV;

    public static CameraEffectResult Default =>
        new CameraEffectResult { overridePosition = false, overrideRotation = false, overrideFOV = false };

    public static CameraEffectResult Position(Vector3 position) =>
        new CameraEffectResult { modifiedPosition = position, overridePosition = true };

    public static CameraEffectResult Rotation(Quaternion rotation) =>
        new CameraEffectResult { modifiedRotation = rotation, overrideRotation = true };

    public static CameraEffectResult FOV(float fov) =>
        new CameraEffectResult { modifiedFieldOfView = fov, overrideFOV = true };
}
```

#### å±å¹•éœ‡åŠ¨æ•ˆæœå®ç°
```csharp
public class CameraShakeEffect : ICameraEffect
{
    public string EffectName => "CameraShake";
    public float Priority { get; set; } = 100f;
    public bool IsActive => isActive && elapsedTime < duration;

    private float duration, amplitude, frequency;
    private AnimationCurve intensityCurve;
    private Vector3 originalPosition;
    private float elapsedTime;
    private Vector3 shakeOffset;
    private bool isActive = false;

    public CameraShakeEffect(float duration = 0.5f, float amplitude = 1.0f, float frequency = 10.0f, float priority = 100f)
    {
        this.duration = duration;
        this.amplitude = amplitude;
        this.frequency = frequency;
        this.Priority = priority;
        this.intensityCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);
    }

    public void Activate(CameraEffectContext context)
    {
        originalPosition = context.basePosition;
        elapsedTime = 0f;
        isActive = true;

        // ä»å‚æ•°ä¸­è·å–è‡ªå®šä¹‰å€¼
        if (context.parameters != null)
        {
            if (context.parameters.ContainsKey("duration"))
                duration = (float)context.parameters["duration"];
            if (context.parameters.ContainsKey("amplitude"))
                amplitude = (float)context.parameters["amplitude"];
            if (context.parameters.ContainsKey("frequency"))
                frequency = (float)context.parameters["frequency"];
        }
    }

    public void Deactivate()
    {
        isActive = false;
        elapsedTime = duration;
    }

    public void Update(float deltaTime)
    {
        if (!isActive) return;
        elapsedTime += deltaTime;
        GenerateShakeOffset();
    }

    public CameraEffectResult ModifyCamera(CameraEffectInput input)
    {
        if (!isActive) return CameraEffectResult.Default;

        float intensity = intensityCurve.Evaluate(elapsedTime / duration);
        Vector3 shakePosition = originalPosition + shakeOffset * intensity * amplitude;

        return CameraEffectResult.Position(shakePosition);
    }

    private void GenerateShakeOffset()
    {
        float time = Time.time;
        float x = Mathf.Sin(time * frequency) * UnityEngine.Random.Range(-1f, 1f);
        float y = Mathf.Cos(time * frequency * 0.5f) * UnityEngine.Random.Range(-1f, 1f);
        float z = Mathf.Sin(time * frequency * 1.5f) * UnityEngine.Random.Range(-1f, 1f);
        shakeOffset = new Vector3(x, y, z).normalized;
    }

    // é™æ€å·¥å‚æ–¹æ³•
    public static CameraShakeEffect CreateImpact(float amplitude = 2.0f)
    {
        var effect = new CameraShakeEffect(0.3f, amplitude, 15.0f);
        effect.SetIntensityCurve(AnimationCurve.EaseInOut(0f, 0f, 0.1f, 1f, 1f, 0f));
        return effect;
    }
}
```

#### æ•Œäººé”å®šæ•ˆæœå®ç°
```csharp
public class CameraLockOnEffect : ICameraEffect
{
    public string EffectName => "CameraLockOn";
    public float Priority { get; set; } = 200f;
    public bool IsActive => isActive && currentLockTarget != null;

    private float lockDistance = 20f;
    private float lockEnemyMaxDistance = 30f;
    private float lockCameraMoveSpeed = 10f;
    private string lockEnemyTag = "Enemy";
    private Vector3 lockOffsetPosition = Vector3.zero;
    private LayerMask lockMask;
    private Transform currentLockTarget;
    private Transform characterTransform;
    private StateManger stateManager;
    private bool isActive = false;

    public void Activate(CameraEffectContext context)
    {
        characterTransform = context.targetTransform;
        isActive = true;

        if (context.parameters != null)
        {
            if (context.parameters.ContainsKey("lockDistance"))
                lockDistance = (float)context.parameters["lockDistance"];
            if (context.parameters.ContainsKey("lockEnemyMaxDistance"))
                lockEnemyMaxDistance = (float)context.parameters["lockEnemyMaxDistance"];
            if (context.parameters.ContainsKey("lockCameraMoveSpeed"))
                lockCameraMoveSpeed = (float)context.parameters["lockCameraMoveSpeed"];
            if (context.parameters.ContainsKey("stateManager"))
                stateManager = (StateManger)context.parameters["stateManager"];
        }

        FindLockTarget();
    }

    public void Deactivate()
    {
        isActive = false;
        currentLockTarget = null;
    }

    public void Update(float deltaTime)
    {
        if (!isActive || currentLockTarget == null) return;

        Vector3 direction = currentLockTarget.position - characterTransform.position;
        if (direction.sqrMagnitude >= lockEnemyMaxDistance * lockEnemyMaxDistance)
        {
            currentLockTarget = null;
            if (stateManager != null) stateManager.HandleLock();
        }
    }

    public CameraEffectResult ModifyCamera(CameraEffectInput input)
    {
        if (!isActive || currentLockTarget == null) return CameraEffectResult.Default;

        Vector3 direction = (currentLockTarget.position + lockOffsetPosition) - input.basePosition;
        direction.Normalize();

        Quaternion targetRotation = Quaternion.LookRotation(direction);
        Quaternion smoothedRotation = Quaternion.Slerp(input.baseRotation, targetRotation, lockCameraMoveSpeed * Time.deltaTime);

        return CameraEffectResult.Rotation(smoothedRotation);
    }

    private bool FindLockTarget()
    {
        // å®ç°ç›®æ ‡å¯»æ‰¾é€»è¾‘ï¼ˆè§å®Œæ•´ä»£ç ï¼‰
        return false;
    }
}
```

#### è·Ÿéšæ•ˆæœå®ç°
```csharp
public class CameraFollowEffect : ICameraEffect
{
    public string EffectName => "CameraFollow";
    public float Priority { get; set; } = 50f;
    public bool IsActive => isActive;

    private float followSpeed = 10f;
    private float followDistance = 5f;
    private float heightLerpSpeed = 10f;
    private Vector3 offsetFromHead = Vector3.zero;
    private CharacterActor characterActor;
    private Rigidbody characterRigidbody;
    private Vector3 lerpedCharacterUp = Vector3.up;
    private float lerpedHeight;
    private Vector3 previousLerpedCharacterUp = Vector3.up;
    private Vector3 characterPosition;
    private bool isActive = false;

    public CameraFollowEffect(float followSpeed = 10f, float followDistance = 5f, float heightLerpSpeed = 10f, float priority = 50f)
    {
        this.followSpeed = followSpeed;
        this.followDistance = followDistance;
        this.heightLerpSpeed = heightLerpSpeed;
        this.Priority = priority;
    }

    public void Activate(CameraEffectContext context)
    {
        characterActor = context.targetTransform.GetComponentInBranch<CharacterActor>();
        if (characterActor != null)
        {
            characterRigidbody = characterActor.GetComponent<Rigidbody>();
        }
        isActive = true;

        if (context.parameters != null)
        {
            if (context.parameters.ContainsKey("followSpeed"))
                followSpeed = (float)context.parameters["followSpeed"];
            if (context.parameters.ContainsKey("followDistance"))
                followDistance = (float)context.parameters["followDistance"];
            if (context.parameters.ContainsKey("offsetFromHead"))
                offsetFromHead = (Vector3)context.parameters["offsetFromHead"];
        }

        characterPosition = context.targetTransform.position;
        previousLerpedCharacterUp = context.targetTransform.up;
        lerpedCharacterUp = previousLerpedCharacterUp;
        lerpedHeight = characterActor.BodySize.y;
    }

    public void Deactivate()
    {
        isActive = false;
    }

    public void Update(float deltaTime)
    {
        if (!isActive || characterActor == null) return;

        characterPosition = characterActor.transform.position;
        lerpedHeight = Mathf.Lerp(lerpedHeight, characterActor.BodySize.y, heightLerpSpeed * deltaTime);
        UpdateCharacterUp(deltaTime);
    }

    public CameraEffectResult ModifyCamera(CameraEffectInput input)
    {
        if (!isActive || characterActor == null) return CameraEffectResult.Default;

        Vector3 targetPosition = characterPosition + characterActor.Up * lerpedHeight +
                               characterActor.transform.TransformDirection(offsetFromHead);

        Vector3 cameraPosition = targetPosition - input.cameraTransform.forward * followDistance;
        return CameraEffectResult.Position(cameraPosition);
    }

    private void UpdateCharacterUp(float deltaTime)
    {
        if (characterActor == null) return;
        lerpedCharacterUp = characterActor.Up;
        Quaternion deltaRotation = Quaternion.FromToRotation(previousLerpedCharacterUp, lerpedCharacterUp);
        previousLerpedCharacterUp = lerpedCharacterUp;
    }
}
```

#### æ•ˆæœç®¡ç†å™¨å®ç°
```csharp
public class CameraEffectManager
{
    private List<ICameraEffect> activeEffects = new List<ICameraEffect>();
    private Dictionary<string, ICameraEffect> effectLookup = new Dictionary<string, ICameraEffect>();
    private Transform cameraTransform;
    private Transform targetTransform;
    private UnityEngine.Camera targetCamera;

    public bool IsEnabled { get; set; } = true;
    public int ActiveEffectCount => activeEffects.Count;
    public IReadOnlyList<ICameraEffect> ActiveEffects => activeEffects;

    public void Initialize(Transform cameraTransform, Transform targetTransform, UnityEngine.Camera targetCamera)
    {
        this.cameraTransform = cameraTransform;
        this.targetTransform = targetTransform;
        this.targetCamera = targetCamera;
    }

    public void AddEffect(ICameraEffect effect, Dictionary<string, object> parameters = null)
    {
        if (effect == null || activeEffects.Contains(effect)) return;

        CameraEffectContext context = new CameraEffectContext
        {
            targetCamera = targetCamera,
            targetTransform = targetTransform,
            basePosition = cameraTransform.position,
            baseRotation = cameraTransform.rotation,
            deltaTime = Time.deltaTime,
            parameters = parameters ?? new Dictionary<string, object>()
        };

        effect.Activate(context);
        activeEffects.Add(effect);
        effectLookup[effect.EffectName] = effect;
        SortEffects();
    }

    public void RemoveEffect(ICameraEffect effect)
    {
        if (effect == null || !activeEffects.Contains(effect)) return;
        effect.Deactivate();
        activeEffects.Remove(effect);
        effectLookup.Remove(effect.EffectName);
    }

    public void UpdateEffects(float deltaTime)
    {
        if (!IsEnabled) return;

        for (int i = activeEffects.Count - 1; i >= 0; i--)
        {
            var effect = activeEffects[i];
            if (effect.IsActive) effect.Update(deltaTime);
            else RemoveEffect(effect);
        }
    }

    public CameraEffectResult CalculateCombinedEffects(CameraEffectInput input)
    {
        if (!IsEnabled || activeEffects.Count == 0) return CameraEffectResult.Default;

        CameraEffectResult result = CameraEffectResult.Default;

        foreach (var effect in activeEffects.OrderByDescending(e => e.Priority))
        {
            if (!effect.IsActive) continue;

            CameraEffectResult effectResult = effect.ModifyCamera(input);

            if (effectResult.overridePosition)
            {
                result.modifiedPosition = effectResult.modifiedPosition;
                result.overridePosition = true;
            }

            if (effectResult.overrideRotation)
            {
                result.modifiedRotation = effectResult.modifiedRotation;
                result.overrideRotation = true;
            }

            if (effectResult.overrideFOV)
            {
                result.modifiedFieldOfView = effectResult.modifiedFieldOfView;
                result.overrideFOV = true;
            }
        }

        return result;
    }

    private void SortEffects()
    {
        activeEffects.Sort((a, b) => b.Priority.CompareTo(a.Priority));
    }
}
```

#### æ ¸å¿ƒç®¡ç†å™¨å®ç°
```csharp
public class CameraManager : Singleton<CameraManager>
{
    private UnityEngine.Camera mainCamera;
    private CameraEffectManager effectManager;
    private CameraConfigManager configManager;
    private CameraEffectPool effectPool;
    private Transform targetTransform;
    private Transform cameraTransform;
    private bool isInitialized = false;

    public bool Initialize(UnityEngine.Camera mainCamera, Transform targetTransform)
    {
        if (isInitialized) return true;

        this.mainCamera = mainCamera;
        this.targetTransform = targetTransform;
        cameraTransform = mainCamera.transform;

        InitializeSubsystems();
        CreateEffectsFromProfile();
        isInitialized = true;
        return true;
    }

    private void InitializeSubsystems()
    {
        effectManager = new CameraEffectManager();
        effectManager.Initialize(cameraTransform, targetTransform, mainCamera);

        configManager = new CameraConfigManager();
        effectPool = CameraEffectPool.Instance;
        effectPool.PrewarmCommonEffects();
    }

    public void UpdateCamera(float deltaTime)
    {
        if (!isInitialized) return;

        effectManager?.UpdateEffects(deltaTime);

        CameraEffectInput input = new CameraEffectInput
        {
            basePosition = cameraTransform.position,
            baseRotation = cameraTransform.rotation,
            baseFieldOfView = mainCamera.fieldOfView,
            targetTransform = targetTransform,
            cameraTransform = cameraTransform,
            activeEffects = new List<ICameraEffect>(effectManager?.ActiveEffects ?? new List<ICameraEffect>())
        };

        CameraEffectResult result = effectManager?.CalculateCombinedEffects(input) ?? CameraEffectResult.Default;
        ApplyEffectResult(result);
    }

    private void ApplyEffectResult(CameraEffectResult result)
    {
        if (result.overridePosition) cameraTransform.position = result.modifiedPosition;
        if (result.overrideRotation) cameraTransform.rotation = result.modifiedRotation;
        if (result.overrideFOV) mainCamera.fieldOfView = result.modifiedFieldOfView;
    }

    public void ApplyEffect(string effectName, Dictionary<string, object> parameters = null)
    {
        switch (effectName)
        {
            case "Shake":
                var shakeEffect = effectPool.GetEffect(() => CameraShakeEffect.CreateImpact(2.0f));
                effectManager.AddEffect(shakeEffect, parameters);
                break;

            case "LockOn":
                var lockEffect = effectPool.GetEffect(CameraLockOnEffect.CreateDefault);
                effectManager.AddEffect(lockEffect, parameters);
                break;
        }
    }

    public void Shake(float duration = 0.5f, float amplitude = 1.0f)
    {
        ApplyEffect("Shake", new Dictionary<string, object>
        {
            { "duration", duration },
            { "amplitude", amplitude }
        });
    }

    public void EnableLockOn() => ApplyEffect("LockOn");
    public void DisableLockOn() => RemoveEffect("CameraLockOn");
}
```

### 4.5 æ€§èƒ½ä¼˜åŒ–å®ç°

#### å¯¹è±¡æ± ç®¡ç†
```csharp
public class CameraEffectPool
{
    private Dictionary<Type, Queue<ICameraEffect>> pools;
    private static CameraEffectPool instance;

    public int TotalPooledObjects { get; private set; }
    public int ActiveObjects { get; private set; }

    public static CameraEffectPool Instance
    {
        get { return instance ?? (instance = new CameraEffectPool()); }
    }

    private CameraEffectPool()
    {
        pools = new Dictionary<Type, Queue<ICameraEffect>>();
        TotalPooledObjects = 0;
        ActiveObjects = 0;
    }

    public T GetEffect<T>() where T : ICameraEffect, new()
    {
        Type effectType = typeof(T);

        if (!pools.ContainsKey(effectType))
        {
            pools[effectType] = new Queue<ICameraEffect>();
        }

        ICameraEffect effect;

        if (pools[effectType].Count > 0)
        {
            effect = pools[effectType].Dequeue();
            TotalPooledObjects--;
        }
        else
        {
            effect = new T();
        }

        effect.Deactivate();
        ActiveObjects++;
        return (T)effect;
    }

    public T GetEffect<T>(System.Func<T> constructor) where T : ICameraEffect
    {
        Type effectType = typeof(T);

        if (!pools.ContainsKey(effectType))
        {
            pools[effectType] = new Queue<ICameraEffect>();
        }

        ICameraEffect effect;

        if (pools[effectType].Count > 0)
        {
            effect = pools[effectType].Dequeue();
            TotalPooledObjects--;
        }
        else
        {
            effect = constructor();
        }

        effect.Deactivate();
        ActiveObjects++;
        return (T)effect;
    }

    public void ReturnEffect(ICameraEffect effect)
    {
        if (effect == null) return;

        Type effectType = effect.GetType();

        if (!pools.ContainsKey(effectType))
        {
            pools[effectType] = new Queue<ICameraEffect>();
        }

        effect.Deactivate();
        pools[effectType].Enqueue(effect);
        TotalPooledObjects++;
        ActiveObjects--;
    }

    public void Prewarm<T>(int count) where T : ICameraEffect, new()
    {
        Type effectType = typeof(T);

        if (!pools.ContainsKey(effectType))
        {
            pools[effectType] = new Queue<ICameraEffect>();
        }

        for (int i = 0; i < count; i++)
        {
            ICameraEffect effect = new T();
            effect.Deactivate();
            pools[effectType].Enqueue(effect);
            TotalPooledObjects++;
        }
    }

    public void PrewarmCommonEffects()
    {
        Prewarm<CameraShakeEffect>(5);
        Prewarm<CameraFollowEffect>(2);
        Prewarm<CameraZoomEffect>(2);
        Prewarm<CameraCollisionEffect>(2);
        Prewarm<CameraTransitionEffect>(3);
    }

    public string GetMemoryUsageInfo()
    {
        int totalEffects = TotalPooledObjects + ActiveObjects;
        return $"æ± å¯¹è±¡: {TotalPooledObjects}, æ´»è·ƒå¯¹è±¡: {ActiveObjects}, æ€»è®¡: {totalEffects}";
    }
}
```

### 4.6 é…ç½®ç³»ç»Ÿå®ç°

#### ç›¸æœºé…ç½®æ¡£æ¡ˆ
```csharp
[Serializable]
public class CameraProfile
{
    public string profileName = "Default";
    public Vector3 defaultOffset = new Vector3(0f, 1.7f, 0f);
    public float defaultDistance = 5f;
    public float minDistance = 2f;
    public float maxDistance = 12f;
    public float rotationSpeed = 180f;
    public float zoomSpeed = 40f;
    public List<EffectConfig> effectConfigs = new List<EffectConfig>();
    public Dictionary<string, object> customParameters = new Dictionary<string, object>();

    public EffectConfig GetEffectConfig(string effectName)
    {
        return effectConfigs.Find(config => config.effectType == effectName);
    }

    public void SetEffectConfig(EffectConfig config)
    {
        int existingIndex = effectConfigs.FindIndex(c => c.effectType == config.effectType);
        if (existingIndex >= 0) effectConfigs[existingIndex] = config;
        else effectConfigs.Add(config);
    }

    public CameraProfile Clone()
    {
        CameraProfile clone = new CameraProfile
        {
            profileName = this.profileName + "_Clone",
            defaultOffset = this.defaultOffset,
            defaultDistance = this.defaultDistance,
            minDistance = this.minDistance,
            maxDistance = this.maxDistance,
            rotationSpeed = this.rotationSpeed,
            zoomSpeed = this.zoomSpeed,
            customParameters = new Dictionary<string, object>(this.customParameters)
        };

        clone.effectConfigs = new List<EffectConfig>();
        foreach (var config in this.effectConfigs)
        {
            clone.effectConfigs.Add(config.Clone());
        }

        return clone;
    }
}

[Serializable]
public class EffectConfig
{
    public string effectType = "";
    public bool enabled = true;
    public float defaultPriority = 100f;
    public Dictionary<string, float> parameters = new Dictionary<string, float>();
    public AnimationCurve intensityCurve;

    public EffectConfig(string effectType)
    {
        this.effectType = effectType;
        this.intensityCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);
    }

    public void SetParameter(string key, float value)
    {
        parameters[key] = value;
    }

    public float GetParameter(string key, float defaultValue = 0f)
    {
        return parameters.TryGetValue(key, out float value) ? value : defaultValue;
    }

    public EffectConfig Clone()
    {
        EffectConfig clone = new EffectConfig(effectType)
        {
            enabled = this.enabled,
            defaultPriority = this.defaultPriority,
            parameters = new Dictionary<string, float>(this.parameters),
            intensityCurve = this.intensityCurve != null ? new AnimationCurve(this.intensityCurve.keys) : null
        };
        return clone;
    }
}
```

#### é…ç½®ç®¡ç†å™¨
```csharp
public class CameraConfigManager
{
    private Dictionary<string, CameraProfile> profiles = new Dictionary<string, CameraProfile>();
    private CameraProfile currentProfile;
    private CameraProfile defaultProfile;

    public CameraProfile CurrentProfile => currentProfile;
    public List<string> ProfileNames => new List<string>(profiles.Keys);

    public CameraConfigManager()
    {
        CreateDefaultProfiles();
    }

    private void CreateDefaultProfiles()
    {
        defaultProfile = new CameraProfile
        {
            profileName = "Default",
            defaultOffset = new Vector3(0f, 1.7f, 0f),
            defaultDistance = 5f,
            minDistance = 2f,
            maxDistance = 12f,
            rotationSpeed = 180f,
            zoomSpeed = 40f
        };

        AddDefaultEffectConfigs(defaultProfile);

        CameraProfile thirdPersonProfile = defaultProfile.Clone();
        thirdPersonProfile.profileName = "ThirdPerson";
        thirdPersonProfile.defaultDistance = 5f;

        CameraProfile firstPersonProfile = defaultProfile.Clone();
        firstPersonProfile.profileName = "FirstPerson";
        firstPersonProfile.defaultOffset = new Vector3(0f, 0.1f, 0f);
        firstPersonProfile.defaultDistance = 0f;

        profiles.Add(defaultProfile.profileName, defaultProfile);
        profiles.Add(thirdPersonProfile.profileName, thirdPersonProfile);
        profiles.Add(firstPersonProfile.profileName, firstPersonProfile);

        currentProfile = defaultProfile;
    }

    private void AddDefaultEffectConfigs(CameraProfile profile)
    {
        EffectConfig followConfig = new EffectConfig("CameraFollow")
        {
            enabled = true,
            defaultPriority = 50f
        };
        followConfig.SetParameter("followSpeed", 10f);
        followConfig.SetParameter("followDistance", 5f);
        followConfig.SetParameter("heightLerpSpeed", 10f);
        profile.SetEffectConfig(followConfig);

        EffectConfig zoomConfig = new EffectConfig("CameraZoom")
        {
            enabled = true,
            defaultPriority = 75f
        };
        zoomConfig.SetParameter("minZoom", 2f);
        zoomConfig.SetParameter("maxZoom", 12f);
        zoomConfig.SetParameter("zoomInOutSpeed", 40f);
        profile.SetEffectConfig(zoomConfig);

        EffectConfig collisionConfig = new EffectConfig("CameraCollision")
        {
            enabled = true,
            defaultPriority = 25f
        };
        collisionConfig.SetParameter("detectionRadius", 0.5f);
        profile.SetEffectConfig(collisionConfig);

        EffectConfig lockConfig = new EffectConfig("CameraLockOn")
        {
            enabled = true,
            defaultPriority = 200f
        };
        lockConfig.SetParameter("lockDistance", 20f);
        lockConfig.SetParameter("lockEnemyMaxDistance", 30f);
        lockConfig.SetParameter("lockCameraMoveSpeed", 10f);
        profile.SetEffectConfig(lockConfig);
    }

    public bool SwitchProfile(string profileName)
    {
        if (profiles.TryGetValue(profileName, out CameraProfile profile))
        {
            currentProfile = profile;
            return true;
        }
        return false;
    }

    public void AddProfile(CameraProfile profile)
    {
        if (profile != null && !string.IsNullOrEmpty(profile.profileName))
        {
            profiles[profile.profileName] = profile;
        }
    }

    public bool RemoveProfile(string profileName)
    {
        return profiles.Remove(profileName);
    }

    public CameraProfile GetProfile(string profileName)
    {
        profiles.TryGetValue(profileName, out CameraProfile profile);
        return profile;
    }

    public void ResetToDefault()
    {
        currentProfile = defaultProfile;
    }
}
```

#### JSONé…ç½®ç¤ºä¾‹
```json
{
  "cameraProfiles": [
    {
      "profileName": "ThirdPerson",
      "defaultOffset": {
        "x": 0.0,
        "y": 1.7,
        "z": 0.0
      },
      "defaultDistance": 5.0,
      "minDistance": 2.0,
      "maxDistance": 12.0,
      "rotationSpeed": 180.0,
      "zoomSpeed": 40.0,
      "effectConfigs": [
        {
          "effectType": "CameraFollow",
          "enabled": true,
          "defaultPriority": 50.0,
          "parameters": {
            "followSpeed": 10.0,
            "followDistance": 5.0,
            "heightLerpSpeed": 10.0
          }
        },
        {
          "effectType": "CameraZoom",
          "enabled": true,
          "defaultPriority": 75.0,
          "parameters": {
            "minZoom": 2.0,
            "maxZoom": 12.0,
            "zoomInOutSpeed": 40.0
          }
        },
        {
          "effectType": "CameraCollision",
          "enabled": true,
          "defaultPriority": 25.0,
          "parameters": {
            "detectionRadius": 0.5
          }
        },
        {
          "effectType": "CameraLockOn",
          "enabled": true,
          "defaultPriority": 200.0,
          "parameters": {
            "lockDistance": 20.0,
            "lockEnemyMaxDistance": 30.0,
            "lockCameraMoveSpeed": 10.0
          }
        }
      ]
    }
  ]
}
```

### 4.7 è°ƒè¯•å’Œç›‘æ§

#### è°ƒè¯•é¢æ¿
```csharp
public class CameraDebugPanel : MonoBehaviour
{
    private void OnGUI()
    {
        GUI.BeginGroup(new Rect(10, 10, 300, 400));

        CameraManager cameraManager = CameraManager.Instance;

        GUI.Label(new Rect(0, 0, 300, 20), "Camera System Debug");
        GUI.Label(new Rect(0, 25, 300, 20), $"Active Effects: {cameraManager.ActiveEffectCount}");
        GUI.Label(new Rect(0, 50, 300, 20), $"Current Profile: {cameraManager.CurrentProfile?.profileName ?? "None"}");
        GUI.Label(new Rect(0, 75, 300, 20), $"Performance: {cameraManager.GetPerformanceMetrics()}");

        // æ•ˆæœåˆ—è¡¨
        int yOffset = 100;
        foreach (var effect in cameraManager.ActiveEffects)
        {
            GUI.Label(new Rect(0, yOffset, 300, 20), $"{effect.EffectName} (Priority: {effect.Priority})");
            yOffset += 25;
        }

        GUI.EndGroup();
    }
}
```

#### æ€§èƒ½ç›‘æ§æ‰©å±•
```csharp
public static class CameraEffectPoolExtensions
{
    public static bool TryGetFromPool<T>(this CameraEffectPool pool, out T effect) where T : ICameraEffect, new()
    {
        try
        {
            effect = pool.GetEffect<T>();
            return true;
        }
        catch
        {
            effect = default;
            return false;
        }
    }

    public static void TryReturnToPool(this CameraEffectPool pool, ICameraEffect effect)
    {
        try
        {
            pool.ReturnEffect(effect);
        }
        catch
        {
            // å›æ”¶å¤±è´¥ï¼Œé™é»˜å¿½ç•¥
        }
    }
}
```

#### è°ƒè¯•å·¥å…·ç±»
```csharp
public static class CameraDebugTools
{
    /// <summary>
    /// è®°å½•ç›¸æœºæ•ˆæœç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    public static void LogEffectStats(CameraManager cameraManager)
    {
        Debug.Log($"=== Camera System Stats ===");
        Debug.Log($"Active Effects: {cameraManager.ActiveEffectCount}");
        Debug.Log($"Current Profile: {cameraManager.CurrentProfile?.profileName ?? "None"}");
        Debug.Log($"Performance: {cameraManager.GetPerformanceMetrics()}");

        Debug.Log("Active Effects List:");
        foreach (var effect in cameraManager.ActiveEffects)
        {
            Debug.Log($"- {effect.EffectName}: Priority={effect.Priority}, Active={effect.IsActive}");
        }

        var poolStats = CameraEffectPool.Instance.GetPoolStats();
        Debug.Log("Object Pool Stats:");
        foreach (var stat in poolStats)
        {
            Debug.Log($"- {stat.Key}: {stat.Value} pooled");
        }
    }

    /// <summary>
    /// å¯è§†åŒ–ç›¸æœºæ•ˆæœå½±å“
    /// </summary>
    public static void VisualizeEffectInfluence(CameraManager cameraManager, UnityEngine.Camera camera)
    {
        if (cameraManager.ActiveEffectCount == 0)
            return;

        // åœ¨Sceneè§†å›¾ä¸­æ˜¾ç¤ºæ•ˆæœå½±å“èŒƒå›´
        foreach (var effect in cameraManager.ActiveEffects)
        {
            switch (effect.EffectName)
            {
                case "CameraCollision":
                    // æ˜¾ç¤ºç¢°æ’æ£€æµ‹çƒ
                    break;
                case "CameraLockOn":
                    // æ˜¾ç¤ºé”å®šèŒƒå›´
                    break;
                case "CameraShake":
                    // æ˜¾ç¤ºéœ‡åŠ¨èŒƒå›´
                    break;
            }
        }
    }

    /// <summary>
    /// éªŒè¯æ•ˆæœä¼˜å…ˆçº§æ’åº
    /// </summary>
    public static bool ValidateEffectPriority(CameraManager cameraManager)
    {
        var effects = cameraManager.ActiveEffects.ToList();
        for (int i = 0; i < effects.Count - 1; i++)
        {
            if (effects[i].Priority < effects[i + 1].Priority)
            {
                Debug.LogError($"Effect priority order incorrect: {effects[i].EffectName} ({effects[i].Priority}) < {effects[i + 1].EffectName} ({effects[i + 1].Priority})");
                return false;
            }
        }
        return true;
    }
}
```

## 5. æœ€ä½³å®è·µæ€»ç»“

### 5.1 è®¾è®¡åŸåˆ™
- **å•ä¸€èŒè´£**: æ¯ä¸ªç±»å’Œæ–¹æ³•åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½
- **å¼€é—­åŸåˆ™**: å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
- **ä¾èµ–å€’ç½®**: ä¾èµ–æŠ½è±¡è€Œä¸æ˜¯å…·ä½“å®ç°
- **ç»„åˆä¼˜äºç»§æ‰¿**: ä½¿ç”¨ç»„åˆå®ç°çµæ´»çš„æ•ˆæœç³»ç»Ÿ

### 5.2 æ€§èƒ½ä¼˜åŒ–
- **å¯¹è±¡æ± åŒ–**: å¤ç”¨ä¸´æ—¶å¯¹è±¡å‡å°‘GCå‹åŠ›
- **è§†é”¥å‰”é™¤**: åªå¤„ç†è§†é‡å†…çš„å¯¹è±¡
- **åˆ†å¸§æ›´æ–°**: å°†å¤æ‚è®¡ç®—åˆ†æ•£åˆ°å¤šå¸§
- **LODç³»ç»Ÿ**: æ ¹æ®è·ç¦»è°ƒæ•´è®¡ç®—ç²¾åº¦

### 5.3 å¯ç»´æŠ¤æ€§
- **é…ç½®å¤–éƒ¨åŒ–**: å°†å‚æ•°ç§»åˆ°é…ç½®æ–‡ä»¶
- **è¯¦ç»†æ³¨é‡Š**: ä¸ºå¤æ‚é€»è¾‘æ·»åŠ è¯´æ˜
- **å•å…ƒæµ‹è¯•**: ä¸ºæ ¸å¿ƒåŠŸèƒ½ç¼–å†™æµ‹è¯•
- **æ–‡æ¡£æ›´æ–°**: ä¿æŒæ–‡æ¡£ä¸ä»£ç åŒæ­¥

### 5.4 æ‰©å±•æ€§è€ƒè™‘
- **æ’ä»¶ç³»ç»Ÿ**: æ”¯æŒç¬¬ä¸‰æ–¹æ•ˆæœæ’ä»¶
- **äº‹ä»¶é©±åŠ¨**: ä½¿ç”¨äº‹ä»¶ç³»ç»Ÿè§£è€¦ç»„ä»¶
- **ç‰ˆæœ¬å…¼å®¹**: è€ƒè™‘å‘åå…¼å®¹æ€§
- **APIè®¾è®¡**: æä¾›æ¸…æ™°çš„å…¬å…±æ¥å£

## 6. å®ç°çŠ¶æ€

### 6.1 å·²å®ç°åŠŸèƒ½

#### æ ¸å¿ƒç³»ç»Ÿ âœ…
- **ICameraEffectæ¥å£** - å®Œæ•´çš„ç›¸æœºæ•ˆæœæ¥å£å®šä¹‰
- **CameraEffectManager** - æ•ˆæœç®¡ç†ç³»ç»Ÿï¼Œæ”¯æŒä¼˜å…ˆçº§æ’åº
- **CameraManager** - æ ¸å¿ƒç®¡ç†å™¨ï¼Œç»Ÿä¸€ç³»ç»Ÿå…¥å£
- **CameraEffectPool** - å¯¹è±¡æ± ç³»ç»Ÿï¼Œä¼˜åŒ–å†…å­˜ä½¿ç”¨

#### åŸºç¡€æ•ˆæœ âœ…
- **CameraShakeEffect** - å±å¹•éœ‡åŠ¨æ•ˆæœ
  - æ”¯æŒå¤šç§éœ‡åŠ¨æ¨¡å¼ï¼ˆå†²å‡»ã€ç¯å¢ƒã€è‡ªå®šä¹‰ï¼‰
  - åŠ¨ç”»æ›²çº¿æ§åˆ¶å¼ºåº¦è¡°å‡
  - éšæœºéœ‡åŠ¨ç®—æ³•
  - é™æ€å·¥å‚æ–¹æ³•
- **CameraLockOnEffect** - æ•Œäººé”å®šæ•ˆæœ
  - è‡ªåŠ¨ç›®æ ‡å¯»æ‰¾å’Œé€‰æ‹©
  - è·ç¦»å’Œè§’åº¦é™åˆ¶
  - ä¸çŠ¶æ€ç®¡ç†å™¨é›†æˆ
  - å¯é…ç½®å‚æ•°
- **CameraFollowEffect** - ç›¸æœºè·Ÿéšæ•ˆæœ
  - å¹³æ»‘è·Ÿéšç®—æ³•
  - é«˜åº¦æ’å€¼å¤„ç†
  - è§’è‰²æœå‘åŒæ­¥
  - ä¼ é€äº‹ä»¶æ”¯æŒ
- **CameraZoomEffect** - ç›¸æœºç¼©æ”¾æ•ˆæœ
  - è·ç¦»é™åˆ¶å’Œæ’å€¼
  - è¾“å…¥å¤„ç†å’Œå“åº”
  - å¤šç§ç¼©æ”¾æ§åˆ¶æ–¹æ³•
  - å¹³æ»‘è¿‡æ¸¡æ”¯æŒ
- **CameraCollisionEffect** - ç¢°æ’æ£€æµ‹æ•ˆæœ
  - çƒå½¢ç¢°æ’æ£€æµ‹
  - åˆšä½“è¿‡æ»¤æœºåˆ¶
  - è·ç¦»è°ƒæ•´ç®—æ³•
  - ç¢°æ’å¯¹ç¼©æ”¾å½±å“
- **CameraTransitionEffect** - è¿‡æ¸¡åŠ¨ç”»æ•ˆæœ
  - å¤šç§è¿‡æ¸¡ç±»å‹
  - åŠ¨ç”»æ›²çº¿æ”¯æŒ
  - è·¯å¾„è¿‡æ¸¡åŠŸèƒ½
  - è¿›åº¦æ§åˆ¶å’Œå®Œæˆæ£€æµ‹

#### é…ç½®ç³»ç»Ÿ âœ…
- **CameraProfile** - ç›¸æœºé…ç½®æ¡£æ¡ˆ
  - åŸºæœ¬ç›¸æœºå‚æ•°é…ç½®
  - æ•ˆæœé…ç½®ç®¡ç†
  - è‡ªå®šä¹‰å‚æ•°æ”¯æŒ
  - é…ç½®å…‹éš†åŠŸèƒ½
- **EffectConfig** - å•ä¸ªæ•ˆæœé…ç½®
  - æ•ˆæœå‚æ•°è®¾ç½®
  - ä¼˜å…ˆçº§é…ç½®
  - å¼ºåº¦æ›²çº¿é…ç½®
- **CameraConfigManager** - é…ç½®ç®¡ç†å™¨
  - å¤šé…ç½®æ¡£æ¡ˆç®¡ç†
  - è¿è¡Œæ—¶é…ç½®åˆ‡æ¢
  - é»˜è®¤é…ç½®åˆ›å»º

#### æ€§èƒ½ä¼˜åŒ– âœ…
- **å¯¹è±¡æ± æ¨¡å¼** - å‡å°‘GCå‹åŠ›
- **é¢„çƒ­æœºåˆ¶** - æé«˜è¿è¡Œæ—¶æ€§èƒ½
- **æ•ˆæœæŸ¥æ‰¾ä¼˜åŒ–** - é«˜æ•ˆçš„æ•ˆæœç®¡ç†
- **å†…å­˜ä½¿ç”¨ç›‘æ§** - æ€§èƒ½æŒ‡æ ‡ç»Ÿè®¡

### 6.2 ä½¿ç”¨ç¤ºä¾‹

#### åŸºæœ¬åˆå§‹åŒ–
```csharp
public class GameManager : MonoBehaviour
{
    void Start()
    {
        CameraManager.Instance.Initialize(Camera.main, player.transform);
    }

    void Update()
    {
        CameraManager.Instance.UpdateCamera(Time.deltaTime);
    }
}
```

#### åº”ç”¨æ•ˆæœ
```csharp
// ç®€å•çš„éœ‡åŠ¨æ•ˆæœ
CameraManager.Instance.Shake(0.5f, 1.5f);

// å¯ç”¨é”å®šåŠŸèƒ½
CameraManager.Instance.EnableLockOn();

// è‡ªå®šä¹‰æ•ˆæœå‚æ•°
CameraManager.Instance.ApplyEffect("Shake", new Dictionary<string, object>
{
    { "duration", 1.0f },
    { "amplitude", 2.0f },
    { "frequency", 15.0f }
});
```

#### é…ç½®åˆ‡æ¢
```csharp
// åˆ‡æ¢åˆ°ç¬¬ä¸€äººç§°é…ç½®
CameraManager.Instance.SwitchProfile("FirstPerson");

// åˆ‡æ¢åˆ°ç¬¬ä¸‰äººç§°é…ç½®
CameraManager.Instance.SwitchProfile("ThirdPerson");

// è·å–å½“å‰é…ç½®
CameraProfile currentProfile = CameraManager.Instance.CurrentProfile;
```

#### æ•ˆæœç®¡ç†
```csharp
// æ·»åŠ è‡ªå®šä¹‰æ•ˆæœ
var customEffect = new CameraShakeEffect(0.8f, 2.0f, 12.0f, 150f);
CameraManager.Instance.AddEffect(customEffect);

// ç§»é™¤æ•ˆæœ
CameraManager.Instance.RemoveEffect("CameraShake");

// æ¸…é™¤æ‰€æœ‰æ•ˆæœ
CameraManager.Instance.ClearAllEffects();
```

#### è°ƒè¯•å’Œç›‘æ§
```csharp
// è®°å½•æ€§èƒ½ç»Ÿè®¡
CameraDebugTools.LogEffectStats(CameraManager.Instance);

// éªŒè¯ä¼˜å…ˆçº§æ’åº
bool isValid = CameraDebugTools.ValidateEffectPriority(CameraManager.Instance);

// è·å–å†…å­˜ä½¿ç”¨ä¿¡æ¯
string memoryInfo = CameraEffectPool.Instance.GetMemoryUsageInfo();
```

### 6.3 ç³»ç»Ÿæ¶æ„ä¼˜åŠ¿

#### ğŸ¯ æ¨¡å—åŒ–è®¾è®¡
- æ¯ä¸ªæ•ˆæœéƒ½æ˜¯ç‹¬ç«‹ç»„ä»¶
- æ”¯æŒåŠ¨æ€æ·»åŠ å’Œç§»é™¤
- æ•ˆæœé—´æ¾è€¦åˆï¼Œé«˜å†…èš

#### âš¡ æ€§èƒ½ä¼˜åŒ–
- å¯¹è±¡æ± å¤ç”¨æœºåˆ¶
- é¢„çƒ­åŠŸèƒ½æå‡æ€§èƒ½
- é«˜æ•ˆçš„æ•ˆæœæŸ¥æ‰¾ç®—æ³•
- å†…å­˜ä½¿ç”¨ç›‘æ§

#### ğŸ›ï¸ é…ç½®é©±åŠ¨
- å¤–éƒ¨é…ç½®æ–‡ä»¶æ”¯æŒ
- è¿è¡Œæ—¶é…ç½®åˆ‡æ¢
- é»˜è®¤å’Œè‡ªå®šä¹‰é…ç½®
- å‚æ•°çƒ­æ›´æ–°

#### ğŸ› ï¸ æ˜“äºæ‰©å±•
- æ¸…æ™°çš„æ¥å£å®šä¹‰
- æ’ä»¶å¼æ¶æ„è®¾è®¡
- æ ‡å‡†åŒ–çš„å¼€å‘æ¨¡å¼
- å®Œæ•´çš„è°ƒè¯•æ”¯æŒ

## 7. æ€»ç»“

RPGæ¸¸æˆçš„æ‘„åƒæœºç³»ç»Ÿæ˜¯ä¸€ä¸ªå¤æ‚çš„ç³»ç»Ÿï¼Œéœ€è¦å¹³è¡¡åŠŸèƒ½ä¸°å¯Œæ€§å’Œæ€§èƒ½è¡¨ç°ã€‚é€šè¿‡æ¨¡å—åŒ–è®¾è®¡å’Œåˆç†çš„æ¶æ„ï¼Œå¯ä»¥å®ç°é«˜åº¦å¯æ‰©å±•å’Œå¯ç»´æŠ¤çš„æ‘„åƒæœºç³»ç»Ÿã€‚

å»ºè®®é‡‡ç”¨æ¸è¿›å¼å¼€å‘ç­–ç•¥ï¼Œä»åŸºç¡€åŠŸèƒ½å¼€å§‹ï¼Œé€æ­¥æ·»åŠ é«˜çº§æ•ˆæœï¼Œå¹¶å§‹ç»ˆä¿æŒç³»ç»Ÿçš„æ¨¡å—åŒ–å’Œå¯é…ç½®æ€§ã€‚

### 6.1 å¼€å‘è·¯çº¿å›¾

#### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ç³»ç»Ÿ (1-2å‘¨)
- å®ç°æ ¸å¿ƒCameraManager
- å»ºç«‹åŸºç¡€è·Ÿéšç³»ç»Ÿ
- æ·»åŠ é…ç½®ç®¡ç†åŠŸèƒ½
- å®ŒæˆåŸºæœ¬ç¢°æ’æ£€æµ‹

#### ç¬¬äºŒé˜¶æ®µï¼šæ•ˆæœç³»ç»Ÿ (2-3å‘¨)
- å®ç°å„ç§æ‘„åƒæœºæ•ˆæœ
- å»ºç«‹æ•ˆæœä¼˜å…ˆçº§ç³»ç»Ÿ
- æ·»åŠ æ•ˆæœç»„åˆé€»è¾‘
- å®ŒæˆçŠ¶æ€ç®¡ç†åŠŸèƒ½

#### ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½ (2-3å‘¨)
- å®ç°åœºæ™¯è¿‡æ¸¡æ•ˆæœ
- æ·»åŠ åŠ¨æ€æ„å›¾ç³»ç»Ÿ
- ä¼˜åŒ–æ€§èƒ½è¡¨ç°
- å®Œå–„è°ƒè¯•å·¥å…·

#### ç¬¬å››é˜¶æ®µï¼šæ‰“ç£¨ä¼˜åŒ– (1-2å‘¨)
- æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–
- ç”¨æˆ·ä½“éªŒè°ƒä¼˜
- æ–‡æ¡£å®Œå–„
- æµ‹è¯•è¦†ç›–

### 6.2 æŠ€æœ¯æ ˆå»ºè®®

#### æ ¸å¿ƒæŠ€æœ¯
- Unity 2021.3+
- C# 8.0+
- Unity Input System
- Unity Cinemachine (å¯é€‰)

#### å¼€å‘å·¥å…·
- Unity Editor
- Visual Studio/Rider
- Unity Test Framework
- Unity Profiler

#### ç¬¬ä¸‰æ–¹åº“
- DOTween (ç¼“åŠ¨åŠ¨ç”»)
- Odin Inspector (ç¼–è¾‘å™¨æ‰©å±•)
- JSON.NET (é…ç½®åºåˆ—åŒ–)